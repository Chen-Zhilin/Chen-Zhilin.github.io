<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Czhlin&#39;s Blog</title>
  <icon>https://www.gravatar.com/avatar/9827fa3822bdd5e6d02ed7ce58a4a1f4</icon>
  <subtitle>天才和疯子总要做一个吧！</subtitle>
  <link href="http://yoursite.com/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2021-04-24T12:37:57.651Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>czhlin</name>
    <email>2324133088@qq.com</email>
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>剑指 Offer 11. 旋转数组的最小数字</title>
    <link href="http://yoursite.com/2020/07/22/%E5%89%91%E6%8C%87%20Offer%2011.%20%E6%97%8B%E8%BD%AC%E6%95%B0%E7%BB%84%E7%9A%84%E6%9C%80%E5%B0%8F%E6%95%B0%E5%AD%97/"/>
    <id>http://yoursite.com/2020/07/22/%E5%89%91%E6%8C%87%20Offer%2011.%20%E6%97%8B%E8%BD%AC%E6%95%B0%E7%BB%84%E7%9A%84%E6%9C%80%E5%B0%8F%E6%95%B0%E5%AD%97/</id>
    <published>2020-07-22T01:56:32.535Z</published>
    <updated>2021-04-24T12:37:57.651Z</updated>
    
    <content type="html"><![CDATA[<h6 id="描述"><a href="#描述" class="headerlink" title="描述:"></a>描述:</h6><p>把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。输入一个递增排序的数组的一个旋转，输出旋转数组的最小元素。例如，数组 [3,4,5,1,2] 为 [1,2,3,4,5] 的一个旋转，该数组的最小值为1。  </p><h6 id="示例1："><a href="#示例1：" class="headerlink" title="示例1："></a>示例1：</h6><blockquote><p>输入: [3,4,5,1,2]<br>输出: 1</p></blockquote><h6 id="示例2"><a href="#示例2" class="headerlink" title="示例2:"></a>示例2:</h6><blockquote><p>输入: [2,2,2,0,1]<br>输出: 0</p></blockquote><h3 id="解题思路："><a href="#解题思路：" class="headerlink" title="解题思路："></a>解题思路：</h3><h4 id="一、遍历法："><a href="#一、遍历法：" class="headerlink" title="一、遍历法："></a>一、遍历法：</h4><p>遍历每一一个元素,对于numbers[i+1]&lt; numbers[i]时直接返回numders[i+1]遍历完仍没找到,则直接返回 numbers[0];</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minArray</span><span class="params">(<span class="keyword">int</span>[] numbers)</span> </span>&#123;</span><br><span class="line">         <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;numbers.length-<span class="number">1</span>;i++)</span><br><span class="line">            <span class="keyword">if</span>(numbers[i]&gt;numbers[i+<span class="number">1</span>]) <span class="keyword">return</span> numbers[i+<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">return</span> numbers[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="二、二分法："><a href="#二、二分法：" class="headerlink" title="二、二分法："></a>二、二分法：</h4><p>numbers[m] &lt; numbers[r]时说明numbers[m]是目标值或者目标值在左边<br>numbers[m] &gt; numbers[r]时说明目标值在左边.<br>numbers[m]==numbers[r]时需要进行r–来试探</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minArray</span><span class="params">(<span class="keyword">int</span>[] numbers)</span> </span>&#123;</span><br><span class="line">         <span class="keyword">int</span> l=<span class="number">0</span>,r=numbers.length-<span class="number">1</span>,m=r/<span class="number">2</span>;</span><br><span class="line">         <span class="keyword">while</span>(l&lt;r)&#123;</span><br><span class="line">             <span class="keyword">if</span>(numbers[m]&lt;numbers[r])r=m;</span><br><span class="line">             <span class="keyword">else</span> <span class="keyword">if</span>(numbers[m]&gt;numbers[r])l=m+<span class="number">1</span>;</span><br><span class="line">             <span class="keyword">else</span> --r;</span><br><span class="line">             m=l+(r-l)/<span class="number">2</span>;</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">return</span> numbers[l];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h6 id=&quot;描述&quot;&gt;&lt;a href=&quot;#描述&quot; class=&quot;headerlink&quot; title=&quot;描述:&quot;&gt;&lt;/a&gt;描述:&lt;/h6&gt;&lt;p&gt;把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。输入一个递增排序的数组的一个旋转，输出旋转数组的最小元素。例如，数组 </summary>
      
    
    
    
    <category term="编程" scheme="http://yoursite.com/categories/%E7%BC%96%E7%A8%8B/"/>
    
    
    <category term="力扣" scheme="http://yoursite.com/tags/%E5%8A%9B%E6%89%A3/"/>
    
  </entry>
  
  <entry>
    <title>不同的二叉搜索树 II</title>
    <link href="http://yoursite.com/2020/07/22/%E4%B8%8D%E5%90%8C%E7%9A%84%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%20II/"/>
    <id>http://yoursite.com/2020/07/22/%E4%B8%8D%E5%90%8C%E7%9A%84%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%20II/</id>
    <published>2020-07-22T01:39:02.374Z</published>
    <updated>2021-04-24T12:36:53.303Z</updated>
    
    <content type="html"><![CDATA[<h2 id="不同的二叉搜索树-II"><a href="#不同的二叉搜索树-II" class="headerlink" title="不同的二叉搜索树 II"></a>不同的二叉搜索树 II</h2><hr><h6 id="描述："><a href="#描述：" class="headerlink" title="描述："></a>描述：</h6><p> 给定一个整数 n，生成所有由 1 … n 为节点所组成的 二叉搜索树 。</p><h6 id="说明："><a href="#说明：" class="headerlink" title="说明："></a>说明：</h6><ul><li>0 &lt;= n &lt;= 8</li></ul><h6 id="示例："><a href="#示例：" class="headerlink" title="示例："></a>示例：</h6><blockquote><p>输入: 3</p></blockquote><blockquote><p>输出: </p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">  [1,null,3,2],</span><br><span class="line">  [3,2,null,1],</span><br><span class="line">  [3,1,null,null,2],</span><br><span class="line">  [2,1,3],</span><br><span class="line">  [1,null,2,null,3]</span><br><span class="line">]</span><br></pre></td></tr></table></figure><blockquote><p>解释: 以上的输出对应以下 5 种不同结构的二叉搜索树：</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1         3     3      2      1</span><br><span class="line"> \       &#x2F;     &#x2F;      &#x2F; \      \</span><br><span class="line">  3     2     1      1   3      2</span><br><span class="line"> &#x2F;     &#x2F;       \                 \</span><br><span class="line">2     1         2                 3</span><br></pre></td></tr></table></figure><h3 id="解题思路："><a href="#解题思路：" class="headerlink" title="解题思路："></a>解题思路：</h3><h4 id="一、递归法："><a href="#一、递归法：" class="headerlink" title="一、递归法："></a>一、递归法：</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span></span><br><span class="line"><span class="comment"> *         this.val = val;</span></span><br><span class="line"><span class="comment"> *         this.left = left;</span></span><br><span class="line"><span class="comment"> *         this.right = right;</span></span><br><span class="line"><span class="comment"> *     &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;TreeNode&gt; <span class="title">generateTrees</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> LinkedList&lt;TreeNode&gt;();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> generateTrees(<span class="number">1</span>, n);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;TreeNode&gt; <span class="title">generateTrees</span><span class="params">(<span class="keyword">int</span> start, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">        List&lt;TreeNode&gt; allTrees = <span class="keyword">new</span> LinkedList&lt;TreeNode&gt;();</span><br><span class="line">        <span class="keyword">if</span> (start &gt; end) &#123;</span><br><span class="line">            allTrees.add(<span class="keyword">null</span>);</span><br><span class="line">            <span class="keyword">return</span> allTrees;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 枚举可行根节点</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = start; i &lt;= end; i++) &#123;</span><br><span class="line">            <span class="comment">// 获得所有可行的左子树集合</span></span><br><span class="line">            List&lt;TreeNode&gt; leftTrees = generateTrees(start, i - <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 获得所有可行的右子树集合</span></span><br><span class="line">            List&lt;TreeNode&gt; rightTrees = generateTrees(i + <span class="number">1</span>, end);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 从左子树集合中选出一棵左子树，从右子树集合中选出一棵右子树，拼接到根节点上</span></span><br><span class="line">            <span class="keyword">for</span> (TreeNode left : leftTrees) &#123;</span><br><span class="line">                <span class="keyword">for</span> (TreeNode right : rightTrees) &#123;</span><br><span class="line">                    TreeNode currTree = <span class="keyword">new</span> TreeNode(i);</span><br><span class="line">                    currTree.left = left;</span><br><span class="line">                    currTree.right = right;</span><br><span class="line">                    allTrees.add(currTree);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> allTrees;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;不同的二叉搜索树-II&quot;&gt;&lt;a href=&quot;#不同的二叉搜索树-II&quot; class=&quot;headerlink&quot; title=&quot;不同的二叉搜索树 II&quot;&gt;&lt;/a&gt;不同的二叉搜索树 II&lt;/h2&gt;&lt;hr&gt;
&lt;h6 id=&quot;描述：&quot;&gt;&lt;a href=&quot;#描述：&quot; clas</summary>
      
    
    
    
    <category term="编程" scheme="http://yoursite.com/categories/%E7%BC%96%E7%A8%8B/"/>
    
    
    <category term="力扣" scheme="http://yoursite.com/tags/%E5%8A%9B%E6%89%A3/"/>
    
  </entry>
  
  <entry>
    <title>两数之和 II - 输入有序数组</title>
    <link href="http://yoursite.com/2020/07/22/%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C%20II%20-%20%E8%BE%93%E5%85%A5%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84/"/>
    <id>http://yoursite.com/2020/07/22/%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C%20II%20-%20%E8%BE%93%E5%85%A5%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84/</id>
    <published>2020-07-22T00:53:35.166Z</published>
    <updated>2021-04-24T12:38:25.710Z</updated>
    
    <content type="html"><![CDATA[<h6 id="描述："><a href="#描述：" class="headerlink" title="描述："></a>描述：</h6><p>给定一个已按照升序排列 的有序数组，找到两个数使得它们相加之和等于目标数。</p><p>函数应该返回这两个下标值 index1 和 index2，其中 index1 必须小于 index2。</p><h6 id="说明："><a href="#说明：" class="headerlink" title="说明："></a>说明：</h6><ul><li>返回的下标值（index1 和 index2）不是从零开始的</li><li>你可以假设每个输入只对应唯一的答案，而且你不可以重复使用相同的元素</li></ul><h6 id="示例："><a href="#示例：" class="headerlink" title="示例："></a>示例：</h6><blockquote><p>输入： numbers = [2, 7, 11, 15], target = 9</p></blockquote><blockquote><p>输出： [1,2]</p></blockquote><blockquote><p>解释：2 与 7 之和等于目标数 9 。因此 index1 = 1, index2 = 2 。</p></blockquote><h3 id="解题思路："><a href="#解题思路：" class="headerlink" title="解题思路："></a>解题思路：</h3><h4 id="一、暴力穷举法："><a href="#一、暴力穷举法：" class="headerlink" title="一、暴力穷举法："></a>一、暴力穷举法：</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*暴力枚举:时间复杂度:O(n*n);空间复杂度:O(1)*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] twoSum(<span class="keyword">int</span>[] numbers, <span class="keyword">int</span> target) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numbers.length-<span class="number">1</span>;i++) &#123;</span><br><span class="line">           <span class="keyword">for</span>(<span class="keyword">int</span> j=i+<span class="number">1</span>;j&lt;numbers.length;j++)&#123;</span><br><span class="line">               <span class="keyword">if</span>(numbers[i]+numbers[j]==target)</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;i+<span class="number">1</span>,j+<span class="number">1</span>&#125;;</span><br><span class="line">           &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;-<span class="number">1</span>, -<span class="number">1</span>&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="二、二分法："><a href="#二、二分法：" class="headerlink" title="二、二分法："></a>二、二分法：</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*二分法:时间复杂度:O(n*logn);空间复杂度:O(1)*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] twoSum(<span class="keyword">int</span>[] numbers, <span class="keyword">int</span> target) &#123;</span><br><span class="line">        <span class="keyword">int</span> l,r,m;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numbers.length; ++i) &#123;</span><br><span class="line">            l= i + <span class="number">1</span>;r= numbers.length - <span class="number">1</span>;m=l+(r-l)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">while</span> (l&lt;=r) &#123;</span><br><span class="line">                <span class="keyword">if</span> (numbers[m] == target - numbers[i])</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;i + <span class="number">1</span>, m+ <span class="number">1</span>&#125;;</span><br><span class="line">                <span class="keyword">if</span> (numbers[m] &gt; target - numbers[i])r=m-<span class="number">1</span>;</span><br><span class="line">                <span class="keyword">else</span> l=m+<span class="number">1</span>;</span><br><span class="line">                m=l+(r-l)/<span class="number">2</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;-<span class="number">1</span>, -<span class="number">1</span>&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="三、哈希表法："><a href="#三、哈希表法：" class="headerlink" title="三、哈希表法："></a>三、哈希表法：</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*哈希表:时间复杂度:O(n);空间复杂度:O(n)*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] twoSum(<span class="keyword">int</span>[] numbers, <span class="keyword">int</span> target) &#123;</span><br><span class="line">        HashMap&lt;Integer,Integer&gt; map=<span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;numbers.length;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(map.containsKey(target-numbers[i]))</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;map.get(target-numbers[i]),i+<span class="number">1</span>&#125;;</span><br><span class="line">            map.put(numbers[i],i+<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;-<span class="number">1</span>,-<span class="number">1</span>&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="四、双指针："><a href="#四、双指针：" class="headerlink" title="四、双指针："></a>四、双指针：</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*双指针:时间复杂度：O(n);空间复杂度O(1)*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] twoSum(<span class="keyword">int</span>[] numbers, <span class="keyword">int</span> target) &#123;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>, right = numbers.length-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(left &lt;right)&#123;</span><br><span class="line">            sum = numbers[left] + numbers[right];</span><br><span class="line">            <span class="keyword">if</span>(sum==target)<span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;left+<span class="number">1</span>, right+<span class="number">1</span>&#125;;</span><br><span class="line">            <span class="keyword">if</span>(sum &gt; target) right--;</span><br><span class="line">            <span class="keyword">else</span> left++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;-<span class="number">1</span>,-<span class="number">1</span>&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="五、二分-双指针："><a href="#五、二分-双指针：" class="headerlink" title="五、二分+双指针："></a>五、二分+双指针：</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*二分+双指针:时间复杂度:O(longn)&lt;=O(n)&lt;=O(logn+n);空间复杂度:O(1)*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] twoSum(<span class="keyword">int</span>[] numbers, <span class="keyword">int</span> target) &#123;</span><br><span class="line">        <span class="keyword">int</span> l=<span class="number">0</span>,r=numbers.length-<span class="number">1</span>,m=r/<span class="number">2</span>,t=target/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">while</span>(l&lt;r)&#123;</span><br><span class="line">            <span class="keyword">if</span>(numbers[m]&lt;t)l=m+<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> r=m;</span><br><span class="line">            m=l+(r-l)/<span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(numbers[r]*<span class="number">2</span> &gt; target)&#123;</span><br><span class="line">            l = r - <span class="number">1</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            l = r;</span><br><span class="line">            r++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(l&gt;=<span class="number">0</span>||r&lt;numbers.length)&#123;</span><br><span class="line">            <span class="keyword">int</span> sum=numbers[l]+numbers[r];</span><br><span class="line">            <span class="keyword">if</span>(sum==target)<span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;l+<span class="number">1</span>,r+<span class="number">1</span>&#125;;</span><br><span class="line">            <span class="keyword">if</span>(sum&lt;target)r++;</span><br><span class="line">            <span class="keyword">else</span> l--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;-<span class="number">1</span>,-<span class="number">1</span>&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h6 id=&quot;描述：&quot;&gt;&lt;a href=&quot;#描述：&quot; class=&quot;headerlink&quot; title=&quot;描述：&quot;&gt;&lt;/a&gt;描述：&lt;/h6&gt;&lt;p&gt;给定一个已按照升序排列 的有序数组，找到两个数使得它们相加之和等于目标数。&lt;/p&gt;
&lt;p&gt;函数应该返回这两个下标值 index1 和</summary>
      
    
    
    
    <category term="编程" scheme="http://yoursite.com/categories/%E7%BC%96%E7%A8%8B/"/>
    
    
    <category term="力扣" scheme="http://yoursite.com/tags/%E5%8A%9B%E6%89%A3/"/>
    
  </entry>
  
  <entry>
    <title>戳气球</title>
    <link href="http://yoursite.com/2020/07/19/%E6%88%B3%E6%B0%94%E7%90%83/"/>
    <id>http://yoursite.com/2020/07/19/%E6%88%B3%E6%B0%94%E7%90%83/</id>
    <published>2020-07-19T04:05:43.521Z</published>
    <updated>2021-04-24T12:37:22.652Z</updated>
    
    <content type="html"><![CDATA[<h6 id="描述："><a href="#描述：" class="headerlink" title="描述："></a>描述：</h6><p>  有 n 个气球，编号为0 到 n-1，每个气球上都标有一个数字，这些数字存在数组 nums 中。</p><p>  现在要求你戳破所有的气球。如果你戳破气球 i ，就可以获得 nums[left] * nums[i] * nums[right]个硬币。 这里的 left 和 right 代表和 i 相邻的两个气球的序号。注意当你戳破了气球 i 后，气球 left 和气球 right 就变成了相邻的气球。</p><p>求所能获得硬币的最大数量。</p><h6 id="说明："><a href="#说明：" class="headerlink" title="说明："></a>说明：</h6><ul><li>你可以假设 nums[-1] = nums[n] = 1，但注意它们不是真实存在的所以并不能被戳破。</li><li>0 ≤ n ≤ 500, 0 ≤ nums[i] ≤ 100<h6 id="示例："><a href="#示例：" class="headerlink" title="示例："></a>示例：</h6><blockquote><p>输入: [3,1,5,8]</p></blockquote></li></ul><blockquote><p>输出: 167 </p></blockquote><blockquote><p>解释: nums = [3,1,5,8] –&gt; [3,5,8] –&gt;   [3,8]   –&gt;  [8]  –&gt; []</p></blockquote><blockquote><p>coins =  3 * 1 * 5      +  3 * 5 * 8    +  1 * 3 * 8      + 1 * 8 * 1   = 167</p></blockquote><h3 id="解题思路："><a href="#解题思路：" class="headerlink" title="解题思路："></a>解题思路：</h3><h4 id="一、回溯法："><a href="#一、回溯法：" class="headerlink" title="一、回溯法："></a>一、回溯法：</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> res = Integer.MIN_VALUE;</span><br><span class="line"><span class="comment">/* 输入一组气球，返回戳破它们获得的最大分数 */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">maxCoins</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    backtrack(nums, <span class="number">0</span>); </span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 回溯算法的伪码解法 */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">backtrack</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> socre)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (nums 为空) &#123;</span><br><span class="line">        res = max(res, score);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> point = nums[i-<span class="number">1</span>] * nums[i] * nums[i+<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">int</span> temp = nums[i];</span><br><span class="line">        <span class="comment">// 做选择</span></span><br><span class="line">        在 nums 中删除元素 nums[i]</span><br><span class="line">        <span class="comment">// 递归回溯</span></span><br><span class="line">        backtrack(nums, score + point);</span><br><span class="line">        <span class="comment">// 撤销选择</span></span><br><span class="line">        将 temp 还原到 nums[i]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="二、动态规划："><a href="#二、动态规划：" class="headerlink" title="二、动态规划："></a>二、动态规划：</h4><p>动态规划算法的一个重要的条件：子问题必须独立。对于戳气球的问题，如果要用动态规划，就必须要巧妙的dp的含义,避免子问题的相关性。</p><h5 id="dp数组的定义："><a href="#dp数组的定义：" class="headerlink" title="dp数组的定义："></a>dp数组的定义：</h5><ul><li>将nums[-1] = nums[n] = 1作为新边界形成新的数组points[n+2];</li><li>对于数组points来说dp[i][j]=x表示：戳破i和j之间所有的气球，可以获得最高的分数为x。</li><li>由于i到j之间可能有多个气球，从正向来看无法推出合理的dp[i][j]的状态转移方程，所以可以从逆向来看。</li><li>设i &lt; k &lt; j,nums[k]表示dp[i][j]中最后戳破的气球。dp[i][j]=max( dp[i][k]+dp[k][j]+nums[i] * nums[k] * nums[j] );</li><li>本题所求dp[0][n+1];</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxCoins</span><span class="params">(<span class="keyword">int</span>[] nums)</span></span>&#123;</span><br><span class="line">        <span class="comment">/*获取nums的长度*/</span></span><br><span class="line">        <span class="keyword">int</span> n=nums.length;</span><br><span class="line">        <span class="comment">/*定义新数组points*/</span></span><br><span class="line">        <span class="keyword">int</span>[] points=<span class="keyword">new</span> <span class="keyword">int</span>[n+<span class="number">2</span>];</span><br><span class="line">        <span class="comment">/*nums[-1]=nums[n]=1*/</span></span><br><span class="line">        points[<span class="number">0</span>]=points[n+<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            points[i+<span class="number">1</span>]=nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/*定义dp数组*/</span></span><br><span class="line">        <span class="keyword">int</span>[][]dp=<span class="keyword">new</span> <span class="keyword">int</span>[n+<span class="number">2</span>][n+<span class="number">2</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=n+<span class="number">1</span>;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">             <span class="keyword">for</span>(<span class="keyword">int</span> j=i;j&lt;=n+<span class="number">1</span>;j++)&#123;</span><br><span class="line">                  <span class="keyword">for</span>(<span class="keyword">int</span> k=i+<span class="number">1</span>;k&lt;j;k++)&#123;</span><br><span class="line">                      <span class="comment">/*dp[i][j]=max( dp[i][k]+dp[k][j]+nums[i] * nums[k] * nums[j] );</span></span><br><span class="line"><span class="comment">                        i&lt;j&lt;j;*/</span></span><br><span class="line">                      dp[i][j]=Math.max(dp[i][j],dp[i][k]+dp[k][j]+points[k]*points[i]*points[j]);</span><br><span class="line">                  &#125;</span><br><span class="line">             &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[<span class="number">0</span>][n+<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h6 id=&quot;描述：&quot;&gt;&lt;a href=&quot;#描述：&quot; class=&quot;headerlink&quot; title=&quot;描述：&quot;&gt;&lt;/a&gt;描述：&lt;/h6&gt;&lt;p&gt;  有 n 个气球，编号为0 到 n-1，每个气球上都标有一个数字，这些数字存在数组 nums 中。&lt;/p&gt;
&lt;p&gt;  现在要求你戳</summary>
      
    
    
    
    <category term="编程" scheme="http://yoursite.com/categories/%E7%BC%96%E7%A8%8B/"/>
    
    
    <category term="力扣" scheme="http://yoursite.com/tags/%E5%8A%9B%E6%89%A3/"/>
    
  </entry>
  
</feed>
